# Claude Code Rules for GPX Predictor

## Перед началом работы

1. **ВСЕГДА** читай `docs/ARCHITECTURE.md` для понимания структуры проекта
2. **ВСЕГДА** читай `docs/ARCHITECTURE_CALCULATIONS.md` перед изменением расчётов
3. **ВСЕГДА** проверяй `docs/CODE_REVIEW.md` для известных проблем

## Калькуляторы времени

В проекте **3 метода расчёта** (все нужны, НЕ удалять и НЕ объединять):

| Метод | Файл | Описание |
|-------|------|----------|
| `tobler` | `calculators/tobler.py` | Tobler's Hiking Function (1993) |
| `naismith` | `calculators/naismith.py` | Naismith + Langmuir corrections |
| `old_naismith` | `services/naismith.py` | Naismith + Tranter's corrections |

Они дают **разные результаты** — это нормально:
```
tobler:       5ч 28мин
naismith:     5ч 15мин
old_naismith: 6ч 26мин
```

## Запреты

- **НЕ** дублировать утилиты — использовать существующие:
  - `haversine` — в `gpx_parser.py` или `segmenter.py`
  - `elevation smoothing` — в `gpx_parser.py` или `segmenter.py`

- **НЕ** создавать новые методы для token refresh/exchange — использовать `StravaClient`

- **НЕ** смешивать sync/async Session без явной необходимости

- **НЕ** удалять или объединять калькуляторы без явного указания

## Документирование

При любых изменениях в коде:

1. **Изменения в расчётах** → обновить `docs/ARCHITECTURE_CALCULATIONS.md`
2. **Изменения в структуре** → обновить `docs/ARCHITECTURE.md`
3. **Исправление проблем из ревью** → обновить статус в `docs/CODE_REVIEW.md`
4. **Новые сервисы/модели** → добавить в `docs/ARCHITECTURE.md`

## Структура проекта

```
backend/app/
├── api/v1/routes/     # API endpoints
├── models/            # SQLAlchemy models
├── schemas/           # Pydantic schemas
├── services/          # Business logic
│   └── calculators/   # Калькуляторы времени
└── repositories/      # Data access
```

## Правила реализации больших фич

### Ограничение размера плана

**КРИТИЧНО:** Перед началом реализации проверь размер плана:
- Если план > 300 строк — **ОБЯЗАТЕЛЬНО** предупреди пользователя
- Предложи разбить на независимые части (максимум 200-300 строк каждая)
- Каждая часть должна быть самодостаточной и тестируемой

Сообщение пользователю:
```
⚠️ План слишком большой ({N} строк).
Рекомендую разбить на части:
- Part 1: {название} (~X строк)
- Part 2: {название} (~Y строк)
...
Реализовать по частям с проверкой каждой?
```

### Чеклист интеграции компонентов

При создании нового сервиса/функции **ОБЯЗАТЕЛЬНО** проверь:

1. **Где вызывается?**
   - [ ] Найти все места, где компонент должен использоваться
   - [ ] Добавить вызовы в эти места
   - [ ] Проверить импорты

2. **Кто вызывает его?**
   - [ ] Если это callback/hook — убедиться, что он зарегистрирован
   - [ ] Если это middleware — добавить в цепочку

3. **Интеграция между модулями:**
   - [ ] Если функция в модуле A должна вызываться из модуля B — проверить оба модуля

### Условная логика

Если в плане есть условия типа:
- "пропустить шаг если..."
- "показать только когда..."
- "использовать если есть..."

**ОБЯЗАТЕЛЬНО:**
1. Явно реализовать проверку условия
2. Добавить обе ветки (if/else)
3. Протестировать оба сценария

### Верификация после реализации

После завершения реализации **ОБЯЗАТЕЛЬНО:**

1. Перечитать исходный план
2. Для каждого пункта плана проверить:
   - [ ] Реализован ли функционал?
   - [ ] Подключен ли к основному flow?
   - [ ] Работает ли интеграция?

3. Создать краткий отчёт:
```
✅ Реализовано: [список]
⚠️ Частично: [список с причинами]
❌ Не реализовано: [список с причинами]
```

### Правило "не забудь подключить"

Создал файл/функцию → Проверь:
- [ ] Добавлен ли import в `__init__.py`?
- [ ] Зарегистрирован ли router в main.py?
- [ ] Вызывается ли функция там, где нужно?
- [ ] Есть ли путь от user action до этого кода?

### Константы и конфигурация

Если создал константу (например, `PROGRESS_NOTIFICATION_INTERVAL = 30`):
- [ ] Убедись, что она **используется** в коде
- [ ] Константа без использования = забытая логика

---

## Известные проблемы (TODO)

См. `docs/CODE_REVIEW.md` для полного списка. Ключевые:

1. Персонализация требует рефакторинга (отдельная задача)
2. Дублирование token management в routes/strava.py
3. Дублирование haversine и elevation smoothing
4. Смешение sync/async Session
